---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ">",
  fig.path = "man/figures/README-"
)
```

```{r, echo = FALSE}
library(packageRank)
```

## packageRank: compute and visualize package download counts and rank percentiles

['packageRank'](https://CRAN.R-project.org/package=packageRank) is an R package that helps put package download counts into context. It does so via two functions, `cranDownloads()` and `packageRank()`. `cranDownloads()` extends [`cranlogs::cran_downloads()`](http://r-hub.github.io/cranlogs/) package by adding a `plot()` method and a more user-friendly interface to the task of counting package downloads. `packageRank()` uses rank percentiles, a nonparametric statistic that tells you the percentage of packages with fewer downloads, to help you see how your package is doing compared to all other packages on [CRAN](https://CRAN.R-project.org/).

NOTE: [‘packageRank’](https://CRAN.R-project.org/package=packageRank)relies on the [‘cranlogs’](https://CRAN.R-project.org/package=cranlogs) package and requires an active internet connection. [‘cranlogs’](https://CRAN.R-project.org/package=cranlogs) uses the [RStudio logs](http://cran-logs.rstudio.com/) to compute package downloads. These logs record traffic to what was previously RStudio’s CRAN mirror (cran.rstudio.com) and is currently the “0-Cloud” mirror (cloud.r-project.org), which is “sponsored by RStudio”. Note that the logs for the previous day are generally posted the next day at 18:00 (GMT+1) or 17:00 UTC (GMT+2) (daylight saving time); results for functions that
rely on ‘cranlogs’ are available soon after.

### I - getting started

To install 'packageRank' from CRAN:

```{r, eval = FALSE}
install.packages("packageRank")
```

To install the development version from GitHub:

```{r, eval = FALSE}
# You may need to first install 'remotes' via install.packages("remotes").
remotes::install_github("lindbrook/packageRank", build_vignettes = TRUE)
```

### II - computing package download counts

`cranDownloads()` uses all the same arguments as `cranlogs::cran_downloads()`:

```{r cran_downloads, eval = FALSE}
cranlogs::cran_downloads(packages = "HistData")
```
```{r cran_downloads_code, echo = FALSE}
cranlogs::cran_downloads(packages = "HistData", from = "2020-05-01", to = "2020-05-01")
```

```{r cranDownloads, eval = FALSE}
cranDownloads(packages = "HistData")
```

```{r cranDownloads_code, echo = FALSE}
cranDownloads(packages = "HistData", from = "2020-05-01", to = "2020-05-01")
```

The only difference is that `cranDownloads()` adds three features:

#### i) check package names

```{r spell_check_fail, eval = FALSE}
cranDownloads(packages = "GGplot2")
```
```
## Error in cranDownloads(packages = "GGplot2") :
##   GGplot2: misspelled or not on CRAN.
```

<br/>
```{r spell_check_pass, eval = FALSE}
cranDownloads(packages = "ggplot2")
```
```{r spell_check_pass_code, echo = FALSE}
cranDownloads(packages = "ggplot2", from = "2020-05-01", to = "2020-05-01")
```

<br/>
This also works for inactive or "retired" packages in the [Archive](https://CRAN.R-project.org/src/contrib/Archive):

```{r check_archive_fail, eval = FALSE}
cranDownloads(packages = "vr")
```
```
## Error in cranDownloads(packages = "vr") :
##  vr: misspelled or not on CRAN/Archive.
```

<br/>
```{r check_archive_pass, eval = FALSE}
cranDownloads(packages = "VR")
```
```{r check_archive_pass_code, echo = FALSE}
cranDownloads(packages = "VR", from = "2020-05-01", to = "2020-05-01")
```

<br/>

#### ii) two additional date formats

With `cranlogs::cran_downloads()`, you specify a time frame using the `from` and `to` arguments. The downside of this is that dates must use the "yyyy-mm-dd" format. For convenience's sake and to reduce typing, `cranDownloads()` also allows you to use "yyyy-mm" or "yyyy" (yyyy also works).

##### "yyyy-mm"
Let's say you want the download counts for ['HistData'](https://CRAN.R-project.org/package=HistData) from February 2020. With `cranlogs::cran_downloads()`, you have to type out the whole date and remember that 2020 was a leap year:

```{r yyyy-mm_1, eval = FALSE}
cranlogs::cran_downloads(packages = "HistData", from = "2020-02-01",
  to = "2020-02-29")
```

<br/>
With `cranDownloads()`, you can just specify the year and month:

```{r yyyy-mm_2, eval = FALSE}
cranDownloads(packages = "HistData", from = "2020-02", to = "2020-02")
```

##### "yyyy"
Let's say you want the year-to-date download counts for ['rstan'](https://CRAN.R-project.org/package=rstan). With `cranlogs::cran_downloads()`, you'd type something like:

```{r yyyy_1, eval = FALSE}
cranlogs::cran_downloads(packages = "rstan", from = "2020-01-01",
  to = Sys.Date() - 1)
```

<br/>
With `cranDownloads()`, you can just type:

```{r yyyy_2, eval = FALSE}
cranDownloads(packages = "rstan", from = "2020")
```

<br/>

#### iii) check dates

`cranDownloads()` tries to check for valid dates:

```{r check_date, eval = FALSE}
cranDownloads(packages = "HistData", from = "2019-01-15",
  to = "2019-01-35")
```
```
## Error in resolveDate(to, type = "to") : Not a valid date.
```

<br/>

### III - visualizing package downloads

`cranDownloads()` makes visualization easy. Just use `plot()`:

```{r cranDownloads_viz1, fig.align = "center"}
plot(cranDownloads(packages = "HistData", from = "2019", to = "2019"))
```

If you pass a vector of package names for a single day, `plot()` returns a dotchart:

```{r cranDownloads_viz2a, fig.align = "center"}
plot(cranDownloads(packages = c("ggplot2", "data.table", "Rcpp"),
  from = "2020-03-01", to = "2020-03-01"))
```

If you pass a vector of package names, `plot()` will use `ggplot2` facets:

```{r cranDownloads_viz2, fig.align = "center"}
plot(cranDownloads(packages = c("ggplot2", "data.table", "Rcpp"),
  from = "2020", to = "2020-03-20"))
```
<br/>

If you want to plot those data in a single frame, use `multi.plot = TRUE`:

```{r cranDownloads_viz3}
plot(cranDownloads(packages = c("ggplot2", "data.table", "Rcpp"),
  from = "2020", to = "2020-03-20"), multi.plot = TRUE)
```

<br/>
If you want separate plots, use `graphics = "base"` (you'll be prompted for each plot):

```{r cranDownloads_viz4, eval = FALSE}
plot(cranDownloads(packages = c("ggplot2", "data.table", "Rcpp"),
  from = "2020", to = "2020-03-20"), graphics = "base")
```

If you want separate, independently scaled plots, add `same.xy = FALSE`:

```{r cranDownloads_viz5, eval = FALSE}
plot(cranDownloads(packages = c("ggplot2", "data.table", "Rcpp"),
  from = "2020", to = "2020-03-20"), graphics = "base", same.xy = FALSE)
```

#### `packages = NULL`

`cranlogs::cran_download(packages = NULL)` computes the total number of package downloads from CRAN.

```{r}
plot(cranDownloads(from = 2019, to = 2019))
```

#### `packages = "R"`

`cranlogs::cran_download(packages = "R")` computes the total number of downloads of the R application (note that you can only use "R" or a vector of packages names, not both!).

```{r}
plot(cranDownloads(packages = "R", from = 2019, to = 2019))
```

#### smoothers and confidence intervals

To add a lowess smoother to your data, use `smooth = TRUE`:

```{r}
plot(cranDownloads(packages = "rstan", from = "2019", to = "2019"),
  smooth = TRUE)
```

With graphs that use 'ggplot2', `se = TRUE` will add confidence intervals:

```{r}
plot(cranDownloads(packages = c("HistData", "rnaturalearth", "Zelig"),
  from = "2020", to = "2020-03-20"), smooth = TRUE, se = TRUE)
```

#### package and R release dates

To annotate a graph with package release dates:

```{r}
plot(cranDownloads(packages = "rstan", from = "2019", to = "2019"),
  package.version = TRUE)
```

To annotate a graph with R release dates:

```{r}
plot(cranDownloads(packages = "rstan", from = "2019", to = "2019"),
  r.version = TRUE)
```

#### population plot

To visualize a package's downloads relative to "all" other packages over time:

```{r}
plot(cranDownloads(packages = "HistData", from = "2020", to = "2020-03-20"),
  population.plot = TRUE)
```

This longitudinal view plots the date (x-axis) against the logarithm of a package's downloads (y-axis). In the background, the same variable are plotted (in gray) for a stratified random sample of packages: within each 5% interval of rank percentiles (e.g., 0 to 5, 5 to 10, 95 to 100, etc.), a random sample of 5% of packages is selected and tracked over time. This sample approximates the "typical" pattern of downloads for that time period.

### IV - computing package download rank percentiles

After looking the download count data for a while, the "compared to what?" question will quickly come to mind. For instance, consider the data for the first week of March 2020:

```{r motivation, eval = FALSE}
plot(cranDownloads(packages = "cholera", from = "2020-03-01",
  to = "2020-03-07"))
```

```{r motivation_code, echo = FALSE, fig.align = "center"}
par(mar = c(5, 4, 4, 4))
plot(cranDownloads(packages = "cholera", from = "2020-03-01",
  to = "2020-03-07"))
par(mar = c(5, 4, 4, 2))
```

Do Wednesday and Saturday reflect surges of interest in the package or surges of traffic to [CRAN](https://CRAN.R-project.org/)? To put it differently, how can we know if a given download count is typical or unusual?

One way to answer these questions is to locate your package in the frequency distribution of download counts. Below are the distributions for Wednesday and Saturday with the location of ['cholera'](https://CRAN.R-project.org/package=cholera) highlighted:

```{r skew_wed, fig.align = "center", echo = FALSE}

x <- packageDistribution("cholera", c("2020-03-04", "2020-03-07"))
freq.dist1 <- x[[1]]$freq.dist
freq.dist2 <- x[[2]]$freq.dist
xlim <- range(freq.dist1$count, freq.dist2$count)
ylim <- range(freq.dist1$frequency, freq.dist2$frequency)

crosstab <- x[[1]]$crosstab
plot(freq.dist1$count, freq.dist1$frequency, xlab = "Downloads",
  ylab = "Frequency", xlim = xlim, ylim = ylim)
pkg.ct <- crosstab[names(crosstab) == x[[1]]$package]
pkg.bin <- crosstab[crosstab == pkg.ct]
axis(3, at = pkg.ct, labels = format(pkg.ct, big.mark = ","),
  cex.axis = 0.8, padj = 0.9, col.axis = "red", col.ticks = "red")
abline(v = pkg.ct, col = grDevices::adjustcolor("red", alpha.f = 0.5))
day <- weekdays(as.Date(x[[1]]$date), abbreviate = TRUE)
title(paste0(x[[1]]$package, " @ ", x[[1]]$date, " (", day, ")"))
```

```{r skew_sat, fig.align = "center", echo = FALSE}

crosstab <- x[[2]]$crosstab
plot(freq.dist2$count, freq.dist2$frequency, xlab = "Downloads",
  ylab = "Frequency", xlim = xlim, ylim = ylim)
pkg.ct <- crosstab[names(crosstab) == x[[2]]$package]
pkg.bin <- crosstab[crosstab == pkg.ct]
axis(3, at = pkg.ct, labels = format(pkg.ct, big.mark = ","),
  cex.axis = 0.8, padj = 0.9, col.axis = "red", col.ticks = "red")
abline(v = pkg.ct, col = grDevices::adjustcolor("red", alpha.f = 0.5))
day <- weekdays(as.Date(x[[2]]$date), abbreviate = TRUE)
title(paste0(x[[2]]$package, " @ ", x[[2]]$date, " (", day, ")"))
```

As you can see, the frequency distribution of package downloads typically has a heavily skewed, exponential shape. On the Wednesday, the most "popular" package had 177,745 downloads while the least "popular" package(s) had just one. This is why the left side of the distribution, where packages with fewer downloads are located, _looks_ like a vertical line.

To see what's going on, I take the log of download counts (x-axis) and redraw the graph. In these plots, the location of a vertical segment along the x-axis represents a download count and the height of a vertical segment represents the frequency of a download count:

```{r packageDistribution, echo = FALSE}
plot_package_distribution <- function(dat, xlim, ylim) {
  freq.dist <- dat$freq.dist
  crosstab <- dat$crosstab
  plot(freq.dist$count, freq.dist$frequency, type = "h", log = "x",
    xlab = "Downloads", ylab = "Frequency", xlim = xlim, ylim = ylim)
  axis(3, at = crosstab[1], cex.axis = 0.8, padj = 0.9, col.axis = "dodgerblue",
    col.ticks = "dodgerblue", labels = paste(names(crosstab[1]), "=",
    format(crosstab[1], big.mark = ",")))
  abline(v = crosstab[1], col = "dodgerblue", lty = "dotted")

  if (!is.null(dat$package)) {
    pkg.ct <- crosstab[names(crosstab) == dat$package]
    pkg.bin <- crosstab[crosstab == pkg.ct]
    axis(3, at = pkg.ct, labels = format(pkg.ct, big.mark = ","),
      cex.axis = 0.8, padj = 0.9, col.axis = "red", col.ticks = "red")
    abline(v = pkg.ct, col = grDevices::adjustcolor("red", alpha.f = 0.5))
    day <- weekdays(as.Date(dat$date), abbreviate = TRUE)
    title(paste0(dat$package, " @ ", dat$date, " (", day, ")"))
  } else title(paste("Distribution of Package Download Counts:", dat$date))
}

distn.data <- packageDistribution(package = "cholera", date = c("2020-03-04",
  "2020-03-07"))

xlim <- range(lapply(distn.data, function(x) x$freq.dist$count))
ylim <- range(lapply(distn.data, function(x) x$freq.dist$frequency))
```

```{r packageDistribution_wed, eval = FALSE}
plot(packageDistribution(package = "cholera", date = "2020-03-04"))
```
```{r packageDistribution_wed_code, echo = FALSE, fig.align = "center"}
plot_package_distribution(distn.data[[1]], xlim, ylim)
```

```{r packageDistribution_sat, eval = FALSE}
plot(packageDistribution(package = "cholera", date = "2020-03-07"))
```
```{r packageDistribution_sat_code, echo = FALSE, fig.align = "center"}
plot_package_distribution(distn.data[[2]], xlim, ylim)
```

While these plots give us a better picture of where ['cholera'](https://CRAN.R-project.org/package=cholera) is located, comparisons between Wednesday and Saturday are impressionistic at best: all we can confidently say is that the download counts for both days were greater than the mode.

To facilitate interpretation and comparison, I use the _rank percentile_ of download counts in place of nominal download counts. This nonparametric statistic tells you the percentage of packages with fewer downloads. In other words, it gives you the location of your package relative to the locations of all other packages. More importantly, by rescaling download counts to lie on the bounded interval between 0 and 100, rank percentiles make it easier to compare packages within and across distributions.

For example, we can compare Wednesday ("2020-03-04") to Saturday ("2020-03-07"):

```{r packageRank1}
packageRank(package = "cholera", date = "2020-03-04", size.filter = FALSE)
```

On Wednesday, we can see that ['cholera'](https://CRAN.R-project.org/package=cholera) had 38 downloads, came in 5,556th place out of 18,038 unique packages downloaded, and earned a spot in the 68th percentile.

```{r packageRank2}
packageRank(package = "cholera", date = "2020-03-07", size.filter = FALSE)
```

On Saturday, we can see that ['cholera'](https://CRAN.R-project.org/package=cholera) had 29 downloads, came in 3,061st place out of 15,950 unique packages downloaded, earned a spot in the 80th percentile.

So contrary to what the nominal counts tell us, one could say that the interest in ['cholera'](https://CRAN.R-project.org/package=cholera) was actually greater on Saturday than on Wednesday.

#### computing rank percentile

To compute rank percentiles, I do the following. For each package, I tabulate the number of downloads and then compute the percentage of packages with fewer downloads. Here are the details using ['cholera'](https://CRAN.R-project.org/package=cholera) from Wednesday as an example:

```{r percentile}
pkg.rank <- packageRank(packages = "cholera", date = "2020-03-04",
  size.filter = FALSE)

downloads <- pkg.rank$crosstab

round(100 * mean(downloads < downloads["cholera"]), 1)
```

To put it differently:

```{r percentile2}
(pkgs.with.fewer.downloads <- sum(downloads < downloads["cholera"]))

(tot.pkgs <- length(downloads))

round(100 * pkgs.with.fewer.downloads / tot.pkgs, 1)
```

For the example above, 38 downloads puts 'HistData' in 5,556th place among the 18,038 packages downloaded.

This rank is "nominal" because multiple packages can have the same number of downloads. As a result, a package's nominal rank (but not its rank percentile) can be affected by its name: packages with the same number of downloads are sorted in alphabetical order.

Thus, 'HistData' benefits from the fact that it is 31st in the list of 263 packages with 38 downloads:

```{r nominal}
pkg.rank <- packageRank(packages = "cholera", date = "2020-03-04",
  size.filter = FALSE)
downloads <- pkg.rank$crosstab

which(names(downloads[downloads == 38]) == "cholera")
length(downloads[downloads == 38])
```

### V - visualizing package download rank percentiles

To visualize `packageRank()`, use `plot()`.

```{r packageRank_plot_wed, eval = FALSE}
plot(packageRank(packages = "cholera", date = "2020-03-04"))
```

```{r packageRank_data, echo = FALSE}
dat <- lapply(c("2020-03-04", "2020-03-07"), function(x) {
  packageRank("cholera", date = x, size.filter = FALSE)
})

crosstab1 <- dat[[1]]$crosstab
crosstab2 <- dat[[2]]$crosstab
xlim <- range(seq_along(crosstab1), seq_along(crosstab2))
ylim <- range(c(crosstab1), c(crosstab2))
```

```{r packageRank_plot_code_wed, echo = FALSE, fig.align = "center"}

crosstab <- dat[[1]]$crosstab
package.data <- dat[[1]]$package.data
pkg <- dat[[1]]$packages
date <- dat[[1]]$date
y.max <- crosstab[1]
q <- stats::quantile(crosstab)[2:4]

iqr <- vapply(c("75%", "50%", "25%"), function(id) {
  dat <- which(crosstab > q[[id]])
  dat[length(dat)]
}, numeric(1L))

plot(seq_along(crosstab), c(crosstab), type = "l", xlab = "Rank",
  ylab = "log10(Count)", log = "y", xlim = xlim, ylim = ylim)
abline(v = iqr, col = "black", lty = "dotted")
iqr.labels <- c("75th", "50th", "25th")
invisible(lapply(seq_along(iqr), function(i) {
  text(iqr[[i]], y.max / 2, labels = iqr.labels[i], cex = 0.75)
}))
abline(v = which(names(crosstab) == pkg), col = "red")
abline(h = crosstab[pkg], col = "red")
pct <- package.data[package.data$package == pkg, "percentile"]
pct.label <- paste0(round(pct, 2), "%")
axis(3, at = which(names(crosstab) == pkg), padj = 0.9, col.axis = "red",
  col.ticks = "red", labels = pct.label, cex.axis = 0.8)
axis(4, at = crosstab[pkg], col.axis = "red", col.ticks = "red",
  cex.axis = 0.8, labels = format(crosstab[pkg], big.mark = ","))
points(which(names(crosstab) == pkg), crosstab[pkg], col = "red")
points(which(names(crosstab) == names(crosstab[1])), y.max,
  col = "dodgerblue")
text(which(names(crosstab) == names(crosstab[1])), y.max, pos = 4,
  labels = paste(names(crosstab[1]), "=", format(crosstab[1],
  big.mark = ",")), cex = 0.8, col = "dodgerblue")
text(max(xlim), max(ylim),
  labels = paste("Tot = ", format(sum(crosstab), big.mark = ",")), cex = 0.8,
  col = "dodgerblue", pos = 2)
day <- weekdays(as.Date(date), abbreviate = TRUE)
title(main = paste0(pkg, " @ ", date, " (", day, ")"))
```

<br/>

```{r packageRank_plot_sat, eval = FALSE}
plot(packageRank(packages = "cholera", date = "2020-03-07"))
```

```{r packageRank_plot_code_sat, echo = FALSE, fig.align = "center"}

crosstab <- dat[[2]]$crosstab
package.data <- dat[[2]]$package.data
pkg <- dat[[2]]$packages
date <- dat[[2]]$date
y.max <- crosstab[1]
q <- stats::quantile(crosstab)[2:4]

iqr <- vapply(c("75%", "50%", "25%"), function(id) {
  dat <- which(crosstab > q[[id]])
  dat[length(dat)]
}, numeric(1L))

plot(seq_along(crosstab), c(crosstab), type = "l", xlab = "Rank",
  ylab = "log10(Count)", log = "y", xlim = xlim, ylim = ylim)
abline(v = iqr, col = "black", lty = "dotted")
iqr.labels <- c("75th", "50th", "25th")
invisible(lapply(seq_along(iqr), function(i) {
  text(iqr[[i]], y.max / 2, labels = iqr.labels[i], cex = 0.75)
}))
abline(v = which(names(crosstab) == pkg), col = "red")
abline(h = crosstab[pkg], col = "red")
pct <- package.data[package.data$package == pkg, "percentile"]
pct.label <- paste0(round(pct, 2), "%")
axis(3, at = which(names(crosstab) == pkg), padj = 0.9, col.axis = "red",
  col.ticks = "red", labels = pct.label, cex.axis = 0.8)
axis(4, at = crosstab[pkg], col.axis = "red", col.ticks = "red",
  cex.axis = 0.8, labels = format(crosstab[pkg], big.mark = ","))
points(which(names(crosstab) == pkg), crosstab[pkg], col = "red")
points(which(names(crosstab) == names(crosstab[1])), y.max,
  col = "dodgerblue")
text(which(names(crosstab) == names(crosstab[1])), y.max, pos = 4,
  labels = paste(names(crosstab[1]), "=", format(crosstab[1],
  big.mark = ",")), cex = 0.8, col = "dodgerblue")
text(max(xlim), max(ylim),
  labels = paste("Tot = ", format(sum(crosstab), big.mark = ",")), cex = 0.8,
  col = "dodgerblue", pos = 2)
day <- weekdays(as.Date(date), abbreviate = TRUE)
title(main = paste0(pkg, " @ ", date, " (", day, ")"))
```

These graphs, customized to be on the same scale, plot the _rank order_ of packages' download counts (x-axis) against the logarithm of those counts (y-axis). It then highlights a package's position in the distribution along with its rank percentile and download count (in red). In the background, the 75th, 50th and 25th percentiles are plotted as dotted vertical lines; the package with the most downloads, which in both cases is ['magrittr'](https://CRAN.R-project.org/package=magrittr) (in blue, top left); and the total number of downloads, 5,561,681 and 3,403,969 respectively (in blue, top right).

### VI - filter "small" downloads

`packageRank()` and `packageLog()` have an additional argument, 'size.filter' that by removes downloads < 1000 bytes. Depending on the day of the week and the number of versions a package has, this can provide a more accurate count of package downloads. For example, here is a raw download count:

```{r filter1}
packageRank(packages = "HistData", date = "2019-10-30", size.filter = FALSE)
```

Below is a filtered count.

```{r filter2}
packageRank(packages = "HistData", date = "2019-10-30", size.filter = TRUE)
```

Besides a difference of 21 downloads, notice that the number of unique packages downloaded falls from 17,396 to 15,330.

By default, `size.filter = TRUE` for `packageRank()` and `size.filter = FALSE` for `packageLog()`.

[blog post](https://blog.r-hub.io/2020/05/11/packagerank-intro/)
"Inflationary Bias of Download Counts"

### VII - memoization

To avoid the bottleneck of downloading multiple log files, `packageRank()` is currently limited to individual days or observations. However, to reduce the need to re-download logs, 'packageRank' makes use of memoization via the 'memoise' package.

Here's relevant code:

```{r memoization, eval = FALSE}
fetchLog <- function(url) data.table::fread(url)

mfetchLog <- memoise::memoise(fetchLog)

if (RCurl::url.exists(url)) {
  cran_log <- mfetchLog(url)
}

# Note that data.table::fread() relies on R.utils::decompressFile().
```

If you use `fetchLog()`, the log file, which can be upwards of 50 MB, will be downloaded every time you call the function. If you use `mfetchLog()`, logs are intelligently cached; those that have already been downloaded, in your current R session, will not be downloaded again.
